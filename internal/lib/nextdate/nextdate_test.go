package nextdate

import (
	"fmt"
	"log"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/Ekvo/yandex-practicum-go-final-project/internal/model"
)

func Test_NextDate(t *testing.T) {
	asserts := assert.New(t)
	requires := require.New(t)

	type nextdate struct {
		date   string
		repeat string
		want   string
	}

	now, _ := time.Parse(model.DateFormat, "20240126")

	validData := []nextdate{
		{"16890126", "y", `20250126`},
		{"16890220", "y", `20240220`},
		{"20250701", "y", `20260701`},
		{"20240101", "y", `20250101`},
		{"20231231", "y", `20241231`},
		{"20240229", "y", `20250301`},
		{"20240301", "y", `20250301`},
		{"20240113", "d 7", `20240127`},
		{"20240120", "d 20", `20240209`},
		{"20240202", "d 30", `20240303`},
		{"20231225", "d 12", `20240130`},
		{"20240228", "d 1", "20240229"},
		{"20231106", "m 13", "20240213"},
		{"20240116", "m 16,5", "20240205"},
		{"20240126", "m 25,26,7", "20240207"},
		{"20240409", "m 31", "20240531"},
		{"20240329", "m 10,17 12,8,1", "20240810"},
		{"20230311", "m 07,19 05,6", "20240507"},
		{"20230311", "m 1 1,2", "20240201"},
		{"20240127", "m -1", "20240131"},
		{"20240222", "m -2", "20240228"},
		{"20240326", "m -1,-2", "20240330"},
		{"20240201", "m -1,18", "20240218"},
		{"20240125", "w 1,2,3", "20240129"},
		{"20240126", "w 7", "20240128"},
		{"20230126", "w 4,5", "20240201"},
	}

	for i, test := range validData {
		log.Printf("\ttest: %d", i+1)

		getDate, err := NextDate(now, test.date, test.repeat)

		requires.NoError(err, fmt.Sprintf("valid Data but error - %v", err))
		asserts.Equal(test.want, getDate, "should be equal")
	}

	invalidData := []nextdate{
		{"20240126", "", ""},
		{"20240126", "k 34", ""},
		{"20240126", "ooops", ""},
		{"16890220", "y ", ""},
		{"20250701", " y", ""},
		{"15000156", "y", ""},
		{"ooops", "y", ""},
		{"20240113", "d", ""},
		{"20240320", "d 401", ""},
		{"20230201", "d 45 17", ""},
		{"20220423", "w ", ""},
		{"20220423", "w1 ", ""},
		{"20220423", "w 1,2,3,4,4", ""},
		{"20210921", "w -1,2,3,4", ""},
		{"20000101", "w ,2,3,4", ""},
		{"20000102", "w 2,3,4,", ""},
		{"20000103", "w 2, 3,4", ""},
		{"20000104", "w 2,3,4 ", ""},
		{"20230226", "w 8,4,5", ""},
		{"20240120", "m2", ""},
		{"20240120", "m2 ", ""},
		{"20240120", "m 40,11,19", ""},
		{"20240121", "m 11,11", ""},
		{"20240121", "m ,12", ""},
		{"20240122", "m 14,", ""},
		{"20240123", "m 15 ", ""},
		{"20210106", "m -1-2,3", ""},
		{"20240222", "m -2,-3", ""},
		{"20240123", "m 15 1,2,2", ""},
		{"20400124", "m 16 1, 2", ""},
		{"20270421", "m 17 1,2,", ""},
		{"20220425", "m 18 ,1,3", ""},
		{"20600714", "m 18 1 ", ""},
		{"20600714", "m 31 2", ""},
	}

	for i, test := range invalidData {
		log.Printf("\ttest: %d", i+1)

		getDate, err := NextDate(now, test.date, test.repeat)
		requires.Error(err, "invalid Data but not error")
		asserts.Empty(getDate, "should be equal")
	}
}
